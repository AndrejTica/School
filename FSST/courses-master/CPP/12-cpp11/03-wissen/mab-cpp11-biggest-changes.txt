mab-cpp11-biggest-changes.txt (18/3)
===============================================================

Ergänze:
(1)---------------------------------------------------------------
	g++ std= ????????? hello.c -o hello.exe

Wie lautet die genaue Ausgabe (inkl. evtl. Zeilenschaltungen)
des folgenden Programmes?
(1)---------------------------------------------------------------
	string test;
	test = R"(First Line.\nSecond line.\nThird Line.\n)";
	cout << test << endl;




richtig oder falsch
(3)---------------------------------------------------------------
	int* a = new int[3] { 1, 2, 0 };
		o richtig
		o falsch

	vector<string> vs={ "first", "second", "third"};
		o richtig
		o falsch

	int arr[] = {1,2,3,4,5};
	for(int& e : arr){
	  e = e*e;
	}
		o richtig
		o falsch

In-Class Initialisierungen sind .....
(1)---------------------------------------------------------------




(2)---------------------------------------------------------------
auto i = 42;        // i ist vom Typ: _____________________

auto p = new Foo(); // p ist vom Typ: _____________________	


Gegeben sei:
(1) ---------------------------------------------------------------
	const vector<int> vi;
	typedef decltype (vi.begin()) FOO;
	FOO another;

	another ist in Wirklichkeit vom Typ ______________________


Was gibt das Programm aus (Beachte evtl. Zeilenschaltungen)?
(1) ---------------------------------------------------------------
	std::map<std::string, std::vector<int>> map;
	std::vector<int> v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	map["one"] = v;
	for(const auto& kvp : map) {
	  std::cout << kvp.first << std::endl;

	  for(auto v& : kvp.second){
		 std::cout << v << std::endl;
	  }
	}
	

Gegeben sei:
(1)---------------------------------------------------------------
	#include <iostream>
	#include <vector>
	#include <algorithm> // for_each, find_if
	using namespace std;

	int main(){
		std::vector<int> v;
		v.push_back(1);
		v.push_back(2);
		v.push_back(3);

		std::for_each(	std::begin(v), 
						std::end(v), 
						[](int n) -> void {cout << n << endl;});

		auto is_odd = [](int n)-> bool {return n%2==1;};

		auto pos = std::find_if(std::begin(v), std::end(v), is_odd);

		if(pos != std::end(v))
			std::cout << *pos << std::endl;

		return 0;
	}

Frage: Was gibt das obige Programm aus?






Gegeben sei:
(2)---------------------------------------------------------------
	#include <iostream>
	#include <algorithm> // for_each
	#include <string>
	using namespace std;

	int main(){
		string s="Hello World!";
		int iUppercase = 0; 

		std::for_each(	std::begin(s), 
					std::end(s), 
					[&iUppercase] (char c) -> void {
						if (isupper(c)) iUppercase++;}
		);

		cout<< iUppercase<<" uppercase letters in: "<< s<<endl;
		return 0;
	}

Frage: Das & bei [&iUppercase] gibt an, dass 
	o per Referenz
	o per Pointer
	o per Wert
	 auf die Variable zugegriffen wird.

Frage: Was gibt das obige Programm aus?

	______ uppercase letters in: Hello World!






Frage: Warum wird hier der Compiler einen Fehler melden?
(1)---------------------------------------------------------------
	class B {
	public:
	   virtual void f(short) {std::cout << "B::f" << std::endl;}
	};

	class D : public B{
	public:
	   virtual void f(int) override {std::cout << "D::f" << std::endl;}
	};

Antwort:





Gegeben sei:
(1)---------------------------------------------------------------
	class NoCopy {
		NoCopy & operator =( const NoCopy & ) = ????????????;
		NoCopy ( const NoCopy & ) = ???????????;
	};
	NoCopy a;
	NoCopy b(a); //compilation error, copy ctor is deleted

Ersetze die ????????????



Frage: Was ist ein RValue bzw. LValue?
(1)---------------------------------------------------------------






Frage: Warum ist eine Referenz auf einen Rvalue sinnvoll?
(1)---------------------------------------------------------------






Es zahlt sich also aus, einer Klasse, die Member mit Zeigern hat, 
folgendes hinzuzufügen:
(1)---------------------------------------------------------------

1) den ____________-Konstruktor und den

2) ___________-Zuweisungsoperator 
