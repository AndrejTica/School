2.Test: Listen/Bäume,Vererbung/new-delete(24)
================================================================================
						NAME:				                  DATUM:
LISTEN/BÄUME (6)
--------------------------------------------------------------------------------
1. richtig oder falsch (BEI FALSCH KORREKTUR ANGEBEN!!!!!!)
1.1. (1) eine 'gekettete Liste' sortiert man am schnellsten mit bubbleSort()
	o richtig
	o falsch ________________________________________________________________


1.2. (0.5) Definieren Sie einen Knoten (SLISTNODE) für eine einfach gekettete 
	Liste, die als data-Komponenten eine Variable (Achtung: Kein Zeiger) des 
	Datentyps TRECHTECK (hat laenge und breite als Strukturkomponenten) enthält.







1.3. (0.5) Definieren Sie einen Listen-Header (SLIST_HEADER) für eine einfach 
	gekettete Liste mit Zeigern auf den ersten und auf den letzten Listenknoten. 
	Zudem soll d. Anzahl der in der Liste gespeicherten Elemente vorhanden sein.







1.4. (4) Vervollständigen Sie folgende Funktion:  
	Die Funktion insertFirst() wurde beim Kopieren beschädigt, sodass das 
	a) richtige Einrücken   b) richtige Reihenfolge der Zeilen verloren ging.
	Korrigieren Sie bitte diese Fehler, indem Sie eine vollständige (ohne ?????)
	und richtige Funktion insertFirst() erstellen.
	Hier sehen Sie die schlechte Kopie von insertFirst():
 
	void insertFirst (SLIST_HEADER* aList, TRECHTECK value){
	if (aList->Len ................) /* -- erster Eintrag ? */
	newPtr->data= ........
	aList->...........= ........;
	{ 
	SLISTNODE *newPtr;  
	aList->First= newPtr;
	if ((newPtr= ( ............) malloc (sizeof (.............)))!= NULL)
	......................++;
	} //end if
	newPtr->next= ........
	} //end insertFirst

















BÄUME (6)
--------------------------------------------------------------------------------
2.1. (1) inorder() liefert die Daten der Knoten des bin. Suchbaumes sortiert
	o richtig
	o falsch ________________________________________________________________

2. Folgende Ausgabe wurde durch postorder() in einem bin.Baum erzeugt. 
		1  2 / 3 * 4 * 5 + 
2.1. (2) Zeichnen Sie den Baum











2.2. (3) Vervollständigen Sie folg. Programm:	
	void postorder(BNODE* ptr){ 








	}


VERERBUNG (8)
--------------------------------------------------------------------------------
Beantworten Sie die folgenden Fragen:

3.1. (1)protected ?



3.2. (1)Welcher Kontruktor wird zuerst fertig ausgeführt:
	o der oberklasse
	o der unterklasse


3.3. (1) Woran erkennt man in cpp eine abstrakte Klasse?




3.4. (1) Was ist ein base initializer ? Wozu wird er benötigt ?




3.5. (1)Wozu werden base class pointers verwendet ?





3.6. (1) Warum gibt es eigentlich Vererbung?





4. Gegeben ist: cipher.h 
	class Cipher{
		public:
			string encrypt(string s, int key);
			string decrypt(string s, int key);

			virtual char encrypt(char ch, int key)=0;
			virtual char decrypt(char ch, int key)=0;
	};

4.1. (2) Gesucht ist: cipher.cpp






NEW/DELETE: Lückentext (4)
--------------------------------------------------------------------------------
5. Gegeben
	class Matrix{
		private:
			int** matrix;
			int rows,cols;
		public:
			Matrix(int r, int c){
				rows=r; cols=c;
				matrix= new ___________________[rows];
				for (int i=0; i< rows; i++){

					matrix_____________________________
				}
			}
			~Matrix(){

				_________________________________

				_________________________________

				_________________________________

				_________________________________

				_________________________________
			}

